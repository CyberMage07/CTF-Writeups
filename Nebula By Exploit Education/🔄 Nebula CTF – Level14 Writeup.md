
---
### ðŸ“œ Challenge Description

> The binary `/home/flag14/flag14` encrypts input using a positional transformation. A **pre-encrypted token file** is in the same directory.
> 
> Your objective: **decrypt the token** and use it to switch to the `flag14` account.

---

### ðŸ§  Understanding the Cipher

The program behaves like this:

```bash
/home/flag14/flag14 -e
```

**Examples:**

```
Input: AAAAA     â†’ Output: ABCDE
Input: 12345     â†’ Output: 13579
Input: BBBBB     â†’ Output: BCDEF
```

ðŸ” **Pattern Observed:**

Each character in the input is **incremented by its index**.

> `output[i] = input[i] + i`

This makes it a **position-based Caesar cipher** â€” the shift amount increases per character.

---

### ðŸ§® Decryption Logic

To reverse it:

> `input[i] = output[i] - i`

Hereâ€™s a quick Python script that does that:

```python
# decrypt_14.py

import sys

def decrypt(data):
    ret = []
    for pos, char in enumerate(data):
        a = ord(char)
        a -= pos
        ret.append(chr(a))
    return "".join(ret)

if __name__ == "__main__":
    print(decrypt(sys.argv[1]))
```

---

### ðŸ”“ Decrypting the Token

Grab the encrypted token and decrypt it:

```bash
cat /home/flag14/token | xargs python decrypt_14.py
```

âœ… **Decrypted Output:**

```
8457c118-887c-4e40-a5a6-33a25353165
```

This is your password for the `flag14` account.

---

### ðŸ Getting the Flag

Now switch users and grab the flag:

```bash
su - flag14
# Password: 8457c118-887c-4e40-a5a6-33a25353165

getflag
```

âœ… Output:

```
You have successfully executed getflag on a target account
```

---

### ðŸ” Takeaway

This level illustrates how even basic encryption can be trivially broken when the transformation is predictable and input/output is observable.

ðŸ›¡ï¸ **Security Tip:**

> Never roll your own encryption. Simple ciphers (like Caesar-based shifts) offer **no real protection** against attackers. Use vetted cryptographic libraries and algorithms.

---
	