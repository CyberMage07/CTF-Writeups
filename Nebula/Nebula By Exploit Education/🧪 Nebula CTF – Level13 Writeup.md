
---
### 🔐 Challenge Description

> A compiled binary performs a **UID check** using `getuid()` before continuing execution. If the UID is not `1000`, it exits with a “Security failure detected” message.

**Login:** `level13 : level13`  
**Target binary:** `/home/flag13/flag13`

---

### 📜 Source Code Overview

```c
if(getuid() != 1000) {
    printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), 1000);
    exit(EXIT_FAILURE);
}
```

🧠 **Insight:**  
The binary expects to be executed by a user with **UID 1000**, but `level13` has a different UID.  
We can **bypass this runtime check** by manipulating the return value of `getuid()` during execution using `gdb`.

---

### 🧰 Exploitation Strategy

This is a **runtime patching exploit** using `gdb`.

We'll:

1. Set a breakpoint **just after** the `getuid()` call.
    
2. Modify the return value register (`eax`) to return `1000` manually.
    
3. Resume execution and bypass the security check.
    

---

### 🛠️ Step-by-Step with GDB

#### 🔧 Step 1: Launch GDB

```bash
gdb /home/flag13/flag13
```

---

#### 🔎 Step 2: Disassemble the `main` function

```gdb
x/20i main
```

Look for this pattern:

```
call   0x80483c0 <getuid@plt>
cmp    $0x3e8,%eax
```

Here:

- `getuid()` is called
    
- Return value in `%eax` is compared to `0x3e8` (decimal 1000)
    

---

#### 🎯 Step 3: Break at the right instruction

We want to intercept execution **just after `getuid()` returns** but **before `cmp` is executed**:

```gdb
break *main+48
run
```

---

#### 🧠 Step 4: Patch the return value

At the breakpoint, force `eax` to return 1000:

```gdb
set $eax = 1000
continue
```

---

### 🏁 Final Result

The binary prints:

```
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
```

🎉 You've successfully bypassed the UID check and retrieved the token!

---

### 🔓 Step 5: Use the Token

```bash
su flag13
# password: level13
getflag
```

✅ Output:

```
You have successfully executed getflag on a target account
```

---

### 🧠 Takeaway

This level demonstrates how **runtime checks** can be bypassed with **debugging tools** like GDB — especially when no integrity checks or memory protection is enforced.

🛡️ **Security Tip:**

> Never rely solely on client-side or runtime user ID checks — especially in binaries. Use access control mechanisms enforced by the OS kernel or sandboxing tools.

---
