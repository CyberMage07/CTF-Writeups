
---
### ğŸ” Challenge Description

> A compiled binary performs a **UID check** using `getuid()` before continuing execution. If the UID is not `1000`, it exits with a â€œSecurity failure detectedâ€ message.

**Login:** `level13 : level13`  
**Target binary:** `/home/flag13/flag13`

---

### ğŸ“œ Source Code Overview

```c
if(getuid() != 1000) {
    printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), 1000);
    exit(EXIT_FAILURE);
}
```

ğŸ§  **Insight:**  
The binary expects to be executed by a user with **UID 1000**, but `level13` has a different UID.  
We can **bypass this runtime check** by manipulating the return value of `getuid()` during execution using `gdb`.

---

### ğŸ§° Exploitation Strategy

This is a **runtime patching exploit** using `gdb`.

We'll:

1. Set a breakpoint **just after** the `getuid()` call.
    
2. Modify the return value register (`eax`) to return `1000` manually.
    
3. Resume execution and bypass the security check.
    

---

### ğŸ› ï¸ Step-by-Step with GDB

#### ğŸ”§ Step 1: Launch GDB

```bash
gdb /home/flag13/flag13
```

---

#### ğŸ” Step 2: Disassemble the `main` function

```gdb
x/20i main
```

Look for this pattern:

```
call   0x80483c0 <getuid@plt>
cmp    $0x3e8,%eax
```

Here:

- `getuid()` is called
    
- Return value in `%eax` is compared to `0x3e8` (decimal 1000)
    

---

#### ğŸ¯ Step 3: Break at the right instruction

We want to intercept execution **just after `getuid()` returns** but **before `cmp` is executed**:

```gdb
break *main+48
run
```

---

#### ğŸ§  Step 4: Patch the return value

At the breakpoint, force `eax` to return 1000:

```gdb
set $eax = 1000
continue
```

---

### ğŸ Final Result

The binary prints:

```
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
```

ğŸ‰ You've successfully bypassed the UID check and retrieved the token!

---

### ğŸ”“ Step 5: Use the Token

```bash
su flag13
# password: level13
getflag
```

âœ… Output:

```
You have successfully executed getflag on a target account
```

---

### ğŸ§  Takeaway

This level demonstrates how **runtime checks** can be bypassed with **debugging tools** like GDB â€” especially when no integrity checks or memory protection is enforced.

ğŸ›¡ï¸ **Security Tip:**

> Never rely solely on client-side or runtime user ID checks â€” especially in binaries. Use access control mechanisms enforced by the OS kernel or sandboxing tools.

---
